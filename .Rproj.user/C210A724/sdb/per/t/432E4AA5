{
    "contents" : "#Video 4-1: Editing text variables\n#Fixing character vectors: tolower(), toupper()\n\nif(!file.exists(\"data\")) {\n  dir.create(\"data\")\n}\nfileUrl <- \"https://data.baltimorecity.gov/api/views/dz54-2aru/rows.csv?accessType=DOWNLOAD\"\nif(!file.exists(\"./data/cameras.csv\")) {\n  download.file(fileUrl, destfile=\"./data/cameras.csv\")\n}\n\n\ncameraData <- read.csv(\"./data/cameras.csv\")\nnames(cameraData)\n#converts the names to lower case\ntolower(names(cameraData))\n\n#converts the names to upper case\ntoupper(names(cameraData))\n\n\n#Fixing character vectors: strsplit()\n#Good for automatically splitting variable names\nsplitNames = strsplit(names(cameraData), split = \"\\\\.\")\nsplitNames[[5]]\nsplitNames[[6]]\n\n#Quick aside: lists\n\n#The following creates a list with three elements, the first two of which are named.\n\nmylist <- list(letters = c(\"A\", \"b\", \"c\"), numbers = 1:3, matrix(1:25, ncol = 5))\nhead(mylist)\nmylist[1]  # returns a list\nmylist$letters  # returns a vector\nmylist[[1]]  # returns a vector\n\nfirstElement <- function(x) {\n  x[1]\n}  # returns first element of x\nsapply(splitNames, firstElement)  # passes each element in splitNames into firstElement\n\n#Peer review experiment data\n\n#Same as used in week 3.\n\n#http://www.plosone.org/article/info:doi/10.1371/journal.pone.0026895\n\nif (!file.exists(\"./data\")) {\n  dir.create(\"./data\")\n}\nfileUrl1 = \"https://dl.dropboxusercontent.com/u/7710864/data/reviews-apr29.csv\"\nfileUrl2 = \"https://dl.dropboxusercontent.com/u/7710864/data/solutions-apr29.csv\"\nif (!file.exists(\"./data/reviews.csv\")) {\n  download.file(fileUrl1, destfile = \"./data/reviews.csv\")\n}\nif (!file.exists(\"./data/solutions.csv\")) {\n  download.file(fileUrl2, destfile = \"./data/solutions.csv\")\n}\nreviews = read.csv(\"./data/reviews.csv\")\nsolutions = read.csv(\"./data/solutions.csv\")\nhead(reviews, 2)\n\n#removing _ in variables - replaces the first underscore\nsub(pattern = \"_\", replacement = \"\", x = names(reviews))\n\n#Fixing character vectors: gsub\n\n#sub replaces only the first match\n#gsub (“global” sub) #replaces all matches\n\ntestName <- \"this_is_a_test\"\nsub(\"_\", \"\", testName)\ngsub(\"_\", \"\", testName)\n\n#searching specific values\n#Finding values: grep, grepl\n\n#grep returns indices of elements in a data set that match a pattern\n#grepl returns an array of TRUE/FALSE values for all elements in a data, TRUE=match\n\ngrep(pattern = \"Alameda\", x = cameraData$intersection)  # Find all intersections that contain 'Alameda\ntable(grepl(pattern = \"Alameda\", x = cameraData$intersection))  # build a table of intersections that do, and do not, contain 'Alameda'\ncameraData2 <- cameraData[!grepl(pattern = \"Alameda\", x = cameraData$intersection), \n                          ]  # subset of intersections that do not contain 'Alameda'\ngrep(pattern = \"Alameda\", x = cameraData$intersection, value = TRUE)  # value=TRUE means return the values, rather than indices to the original data set\ngrep(\"JeffStreet\", cameraData$intersection)  # if no matches, returns intger(0)\n\n#More useful string functions\n\n#Note: nchar, substr, paste, paste0 are all in base R.\n\nlibrary(stringr)\nnchar(\"Jeffrey Leek\") #fives the number of xtersa\nsubstr(\"Jeffrey Leek\", 1, 7) #finds the first throught the 7th letttr\npaste(\"Jeffrey\", \"Leek\")  # sep defaults to ' '\n\npaste0(\"Jeffrey\", \"Leek\")  # there is no sep param, just concatenates\nstr_trim(\"Jeff      \")  # trims trailing whitespace\n\nstr_trim(\"           Jeff        \", side = \"both\")  # or on both sides (can be left, right, both)\n\n#Video 4-2: #Regular Expressions I\n\n#Regular expressions were introduced in previous video, this section will explore regex more fully.\n\n\n\nmorning$ #$ represents the end of a line\n  \n#(Note: The ^ metacharacter means “start of line”; it is the only metacharacter I've ever seen that represents the start of a line.)\n#^i think\n  \n  #You can combine metacharacters. The following matches either “i am” or “I am”, so long as it is at the start of a line:\n  \n # ^[Ii] am\n#NOTE: Order most certainly does matter. If you specify [z-a] it is very different from [a-z]! I think what is meant here is that if you combine more than one range of letters in a single class, then the order of the ranges doesn't matter, e.g., [a-zA-Z] is the same as [A-Za-z].\n\n#So this:\n\n#^[0-9][a-zA-Z]\n\n#For example this: shows one value should not start with a ? or a .\n  \n  [^?.]$\n\n  #starts with a good and has a bBad in it\n  ^([Gg]ood|[Bb]ad)\n\n#the following matches “George Bush”, “george bush”, “George W. Bush”, “george w. bush”. So it will match with or without a “ W.” between “George” and “Bush”.\n\n[Gg]eorge( [Ww]\\.)? [Bb]ush\n\nMore metacharacters: * and +\n  \n  #The * metacharacter means \"any number of the preceding character/expression”, and + means “one or more of the preceding character/expression”.\n\n#So this:\n\n    (.*) i.e \\(.*\\)\n#will match any line that has one or more digits, followed by a space, \n#followed by zero or more of any character, followed by one or more digits.\n[0-9]+ (.*)[0-9]+\n  \n#   /*\n#   These metacharacters are used to define the minimum and maximum number of matches of an expression. For example this:\n#   \n#   [Bb]ush( +[^ ]+ +){1,5} debate\n# \n# looks for the following, in order:\n#   \n#   Either “Bush” or “bush”\n# The following, from 1 to 5 times:\n#   one or more spaces\n# one or more characters that are anything but a space\n# one or more spaces\n# “ debate”\n# \n# So in a sense, it looks for “Bush”, then one to five words, then “debate” (note that this is not an entirely accurate desription, one of those “words” might be an ellipse, “…”, and this hints at the difficulties you can face with regular experssions. Did I mention is't an art?)\n# If you use {3} in the above, it means match exactly three times. If you use {2,7} it means match between 2 and 7 times. If you use {3,} it means match at least three times.\n#   */\n\n#define a pattern that is repeated once\n#So this:defines a character/literal that is repeated once\n\n+([a-zA-Z]+) \\1\n\n# #“Greedy” matches\n# \n# The * metacharacter is “greedy” by default, so this:\n#   \n#   ^s(.*)s\n# \n# will match as many characters as possible after the “s” at the beginning of a line. For example, if the string searched is “soon as pass” then it will not match “soon as”, but rather, “soon as pass”. It will match as many characters as it possibly can.\n# \n# What if you want to match starting with an s, then any characters, but up to and including only the second s in the line? Do this:\n#   \n#   ^s(.*?)s\n\n#working with dates\ndi <- date()\ndi\nd2 <- Sys.Date()\nd2\n\n# #formating dates\n# format(d2,\"%a %b %d\")\n# %d = day as number (0-31)\n# %a = abbreviated weekday\n# %A = unabbreviated weekday\n# %m=month(00-12)\n# %b = abbreviated month\n# %B unabbreviated month\n# %y 2 digit year\n# %Y - four digit year\n\nx <- c(\"1jan1960\",\"2jan1960\",\"31mar1960\",\"30jul1960\")\nz <- as.Date(x,\"%d%b%Y\")\nz[1]-z[2]\n  \n  #converting to Julian --days since some origin\n  weekdays(d2)\n  month(d2)\n  julian(d2)\n\nlibrary(lubridate)\nymd(\"20140108\")\nmdy(\"08/04/2012\")\ndmy(\"03-04-2013\")\n#dealing with times\nymd_hms(\"2011-08-03 10:15:03\")\nymd_hms(\"2011-08-03 10:15:03\",tz=\"Pacific/Auckland\")\n",
    "created" : 1402215612493.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3479823289",
    "id" : "432E4AA5",
    "lastKnownWriteTime" : 1401428302,
    "path" : "E:/R_CLass/Data_Science_Spe/Getting_cleaning_data/project/week3_cleaningData_texts.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}